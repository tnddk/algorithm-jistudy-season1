## 1. 개요

DP, 즉 다이나믹 프로그래밍(또는 동적 계획법)은 기본적인 아이디어로 **하나의 큰 문제를 여러 개의 작은 문제로 나누어서 그 결과를 저장하여 다시 큰 문제를 해결할 때 사용**하는 것으로 특정한 알고리즘이 아닌 하나의 문제해결 패러다임으로 볼 수 있다.

Richard Bellman이 1950년대에 사용한 단어로 이름은 그냥 멋있어 보여서 그렇게 지어졌으니 신경 쓰지 않아도 된다.**큰 문제를 작은 문제로 쪼개서 그 답을 저장해두고 재활용**한다. 그래서 혹자는 DP가 아닌 **'기억하며 풀기'**라고 부르기도 한다.

## 2. DP를 쓰는 이유

왜 DP를 사용할까? 사실 일반적인 재귀(Naive Recursion) 방식 또한 DP와 매우 유사하다. 큰 차이점은 **일반적인 재귀를 단순히 사용 시 동일한 작은 문제들이 여러 번 반복 되어 비효율적인 계산**될 수 있다는 것이다.

예를 들어 피보나치 수열을 살펴보자. 피보나치 수열은 아래와 같다.1,  1,  2,  3,  5,  8,  13,  21,  34,  55,  89,  144 ...

피보나치 수를 구하고 싶을 때 재귀로 함수를 구성하면 어떻게 될까? 단순하다. return f(n) = f(n-1) + f(n-2)

그런데 f(n-1), f(n-2)에서 각 함수를 1번씩 호출하면 동일한 값을 2번씩 구하게 되고 이로 인해 100번째 피보나치 수를 구하기 위해 호출되는 함수의 횟수는 기하급수 적으로 증가한다.

왜냐하면, f(n-1)에서 한 번 구한 값을 f(n-2)에서 또 다시 같은 값을 구하는 과정을 반복하게 되기 때문이다. 아래의 그림처럼 반복되는 계산을 또 하게 된다.

![image](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/389b3d81-f2bb-4759-ab84-be5afb2caa76/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20221227%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20221227T063403Z&X-Amz-Expires=86400&X-Amz-Signature=390827fe11e3ab97ed5996404dd7dca558b4c393133b45ac3d60f347b08deb7b&X-Amz-SignedHeaders=host&response-content-disposition=filename%3D%22Untitled.png%22&x-id=GetObject)

그러나 한 번 구한 작은 문제의 결과 값을 저장해두고 재사용 한다면 어떨까? 앞에서 계산된 값을 다시 반복할 필요가 없이 약 200회 내에 계산이 가능해진다.

즉, 매우 효율적으로 문제를 해결할 수 있게 된다. 시간복잡도를 기준으로 아래와 같이 개선이 가능하다.**O(n^2) → O(f(n)) 로 개선** (다항식 수준으로, 문제에 따라 다름.)

## 3. DP의 사용 조건

DP가 적용되기 위해서는 2가지 조건을 만족해야 한다.

**1) Overlapping Subproblems(겹치는 부분 문제)
2) Optimal Substructure(최적 부분 구조)**

**① Overlapping Subproblems(겹치는 부분 문제)**

DP는 기본적으로 문제를 나누고 그 문제의 결과 값을 재활용해서 전체 답을 구한다. 그래서 **동일한 작은 문제들이 반복하여 나타나는 경우에 사용이 가능**하다.

즉, DP는 부분 문제의 결과를 저장하여 재 계산하지 않을 수 있어야 하는데, 해당 **부분 문제가 반복적으로 나타나지 않는다면 재사용이 불가능하니 부분 문제가 중복되지 않는 경우에는 사용할 수 없다.**

**② Optimal Substructure(최적 부분 구조)**

**부분 문제의 최적 결과 값을 사용해 전체 문제의 최적 결과를 낼 수 있는 경우**를 의미한다. 그래서 특정 문제의 정답은 문제의 크기에 상관없이 항상 동일하다!

## 4. DP 사용하기

DP는 **특정한 경우에 사용하는** **알고리즘이 아니라 하나의 방법론이므로 다양한 문제해결에 쓰일 수 있다.** 그래서 DP를 적용할 수 있는 문제인지를 알아내는 것부터 코드를 짜는 과정이 난이도가 쉬운 것부터 어려운 것까지 다양하다.

일반적으로 DP를 사용하기 전에는 아래의 과정을 거쳐 진행할 수 있다.

**1) DP로 풀 수 있는 문제인지 확인한다.**

보통 특정 데이터 내 최대화 / 최소화 계산을 하거나 특정 조건 내 데이터를 세야 한다거나 확률 등의 계산의 경우 DP로 풀 수 있는 경우가 많다.

**2) 문제의 변수 파악**

예를 들어, **피보나치 수열**에서는 n번째 숫자를 구하는 것이므로 n이 변수가 된다. 그 변수가 얼마이냐에 따라 결과값이 다르지만 그 결과를 재사용하고 있다.

또한, **문자열 간의 차이**를 구할 때는 문자열의 길이, Edit 거리 등 2가지 변수를 사용한다. 해당 문제를 몰라도 된다.

또, 유명한 **Knapsack 문제**에서는 index, 무게로 2가지의 변수를 사용한다. 이와 같이 해당 문제에서 어떤 변수가 있는지를 파악해야 그에 따른 답을 구할 수 있다.

**3) 변수 간 관계식 만들기(점화식)
4) 메모하기(memoization or tabulation)**

변수 간 관계식까지 정상적으로 생성되었다면 **변수의 값에 따른 결과를 저장**해야 한다. 이것을 메모한다고 하여 **Memoization**이라고 부른다.

변수 값에 따른 결과를 저장할 배열 등을 미리 만들고 그 결과를 나올 때마다 배열 내에 저장하고 그 저장된 값을 재사용하는 방식으로 문제를 해결해 나간다.

**5) 기저 상태 파악하기**

**가장 작은 문제의 상태를 알아야** 한다. 보통 몇 가지 예시를 직접 손으로 테스트하여 구성하는 경우가 많다.

**피보나치 수열을 예시로 들면, f(0) = 0, f(1) = 1과 같은 방식**이다.

**6) 구현하기**

DP는 2가지 방식으로 구현할 수 있다.

**1) Bottom-Up (Tabulation 방식) - 반복문 사용**

이름에서 보이듯이, **아래에서 부터 계산을 수행 하고 누적시켜서 전체 큰 문제를 해결하는 방식**이다.

메모를 위해서 dp라는 배열을 만들었고 이것이 1차원이라 가정했을 때, dp[0]가 기저 상태이고 dp[n]을 목표 상태라고 하자. Bottom-up은 dp[0]부터 시작하여 반복문을 통해 점화식으로 결과를 내서 dp[n]까지 그 값을 전이시켜 재활용하는 방식이다.

**왜 Tabulation?**

사실 위에서 메모하기 부분에서 Memoization이라고 했는데 Bottom-up일 때는 Tabulation이라고 부른다.

왜냐면 반복을 통해 dp[0]부터 하나 하나씩 채우는 과정을 **"table-filling"** 하며, 이 Table에 저장된 값에 직접 접근하여 재활용하므로 **Tabulation**이라는 명칭이 붙었다고 한다.

사실상 근본적인 개념은 결과값을 기억하고 재활용한다는 측면에서 메모하기(Memoization)와 크게 다르지 않다.

**2) Top-Down (Memoization 방식) - 재귀 사용**

이는 dp[0]의 기저 상태에서 출발하는 대신 dp[n]의 값을 찾기 위해 **위에서 부터 바로 호출을 시작**하여 dp[0]의 상태까지 내려간 다음 해당 **결과 값을 재귀를 통해 전이시켜 재활용하는 방식**이다.

피보나치의 예시처럼, f(n) = f(n-2) + f(n-1)의 과정에서 함수 호출 트리의 과정에서 보이듯, n=5일 때, f(3), f(2)의 동일한 계산이 반복적으로 나오게 된다.

이 때, 이미 이전에 계산을 완료한 경우에는 단순히 메모리에 저장되어 있던 내역을 꺼내서 활용하면 된다. 그래서 가장 최근의 상태 값을 메모해 두었다고 하여 **Memoization** 이라고 부른다.